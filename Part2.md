# ЧАСТЬ II Введение в объектно-ориентированное программирование

<!-- TOC -->

- [ЧАСТЬ II Введение в объектно-ориентированное программирование](#часть-ii-введение-в-объектно-ориентированное-программирование)
    - [Глава 12. Парадигмы программирования](#глава-12-парадигмы-программирования)
        - [Состояние](#состояние)
        - [Процедурное программирование](#процедурное-программирование)
        - [Функциональное программирование](#функциональное-программирование)
        - [Объектно-ориентированное программирование](#объектно-ориентированное-программирование)
        - [Словарь терминов Глава 12](#словарь-терминов-глава-12)

<!-- /TOC -->

## Глава 12. Парадигмы программирования

> Существуют лишь два вида языков программирования: те, которые постоянно ругают, и те, которыми никто не пользуется.
> *Бьерн Страуструп*

**Парадигма программирования** — это стиль программирования. Существует множество различных парадигм программирования. Для того чтобы программировать профессионально, вам нужно изучить парадигмы либо объектно-ориентированного, либо функционального программирования.

### Состояние

Одним из фундаментальных различий между разными парадигмами программирования является управление **состоянием.** Состояние — это значение переменных в программе при ее работе. **Глобальное состояние** — значение глобальных переменных в программе при ее работе.  

### Процедурное программирование

В части I вы программировали, используя парадигму процедурного программирования — стиль программирования, в котором пишется последовательность шагов по направлению к решению, и каждый шаг изменяет состояние программы. В процедурном программировании вы пишете код, чтобы «сделать это, затем то».  
Когда вы используете процедурное программирование, то сохраняете данные в глобальных переменных и управляете ими при помощи функций. Процедурное программирование подходит для написания небольших программ. Что все состояния программы сохраняются в глобальных переменных, когда код становится больше, появляются проблемы. Проблема с использованием глобальных переменных заключается в том, что они вызывают непредвиденные ошибки. Когда код вашей программы увеличивается в размере, вы используете глобальные переменные в большом количестве функций, и невозможно отследить все места, в которых глобальная переменная изменяется. Например, функция может изменить значение глобальной переменной, а позже в программе другая функция может изменить ту же глобальную переменную, потому что программист, написавший вторую функцию, забыл, что глобальная переменная уже была изменена первой функцией. Подобные ситуации возникают довольно часто, искажая код программы.  

По мере того, как ваша программа усложняется, количество глобальных пе ременных в ней возрастает. Когда это возрастание совмещается с увеличением числа функций, необходимых программе для обработки новой функциональности, каждая из которых изменяет глобальные переменные, код вашей программы быстро становится непригодным для обслуживания. Более того, этот подход к программированию опирается на **побочные эффекты.** Побочный эффект — это изменение состояния глобальной переменной. При процедурном программировании вы будете часто сталкиваться с непреднамеренными побочными эффектами, такими как случайное двукратное увеличение переменной. Эта проблема привела к развитию парадигм объектно-ориентированного и функционального программирования, и эти парадигмы используют разные подходы к ее решению.  

### Функциональное программирование

Функциональное программирование происходит от лямбда-исчисления — наименьшего в мире универсального языка программирования (созданного математиком Алонзо Черчем). Функциональное программирование решает проблемы процедурного программирования с помощью устранения глобального состояния. Функциональный программист полагается на функции, которые не используют и не изменяют глобальное состояние; единственное используемое ими состояние — параметры, которые вы передаете в функцию. Результат, возвращаемый функцией, обычно передается в другую функцию. Таким образом, выполняя передачу из функции в функцию, функциональный программист избегает глобального состояния. Отказ от глобального состояния избавляет от побочных эффектов и сопутствующих им проблем.  

Программист из Великобритании, Мэри Роуз Кук, дает функциональному программированию такое определение: «Функциональный код отличается одним свойством: отсутствием побочных эффектов. Он не полагается на данные вне текущей функции, и не меняет данные, находящиеся вне функции».  

Преимущество функционального программирования заключается в том, что оно устраняет целую категорию ошибок, вызванных глобальным состоянием (в функциональном программировании нет глобального состояния). Его недостаток заключается в том, что некоторые проблемы легче осмыслить при помощи состояния. К примеру, проектирование пользовательского интерфейса с глобальным состоянием легче концептуализировать, чем интерфейс без него. Если вы хотите написать программу, где будет кнопка, нажатие которой переключает режим изображения между видимым и скрытым, такую кнопку проще создать в программе с глобальным состоянием. Можно создать глобальную переменную, принимающую значение `True` или `False` и в зависимости от своего те кущего состояния скрывающую или показывающую это изображение. Без глобального состояния создать такую кнопку сложнее.  

### Объектно-ориентированное программирование

Парадигма **объектно-ориентированного программирования** также решает проблемы, возникающие в процедурном программировании путем устранения глобального состояния, но здесь состояние сохраняется не в функциях а в объектах. В объектно-ориентированном программировании **классы** определяют набор объектов, которые могут взаимодействовать между собой. Классы являются механизмом, позволяющим программисту классифицировать и сгруппировывать похожие объекты. Представьте пакет апельсинов. Каждый апельсин — это объект. Все апельсины обладают схожими свойствами, такими как цвет и вес, но значения этих свойств разные у каждого апельсина. Вы можете использовать класс, чтобы смоделировать апельсины и создать объекты апельсинов с разными значениями. Например, можно определить класс, позволяющий создать объект апельсина темного цвета, весящего 300 грамм, и объект светлого апельсина весом 350 грамм.  

Каждый объект — это **экземпляр** класса. Если вы определите класс `Orange` и создадите два объекта `Orange`, каждый из них будет экземпляром класса `Orange`, и у них будет одинаковый тип данных — Orange. Термины «объект» и «экземпляр» взаимозаменяемы. При определении класса экземпляры класса будут похожими — они все будут иметь свойства, определенные в их классе, как цвет или вес для класса, представляющего апельсин, — но свойства каждого экземпляра будут иметь разные значения.  

В Python класс является составной инструкцией с заголовком и телом . Класс определяется при помощи синтаксиса `class имя: тело`, где `имя` — это имя класса, `тело` — определяемое вами тело класса. По соглашению, имена классов в Python всегда начинаются с прописной буквы и записываются в **горбатом регистре,** то есть при наличии в имени класса больше одного слова первые буквы всех слов нужно сделать прописными (`LikeThis`), а не добавлять между словами нижние подчеркивания, как с именами функций. Тело в классе может быть простой или составной инструкцией, называемой **методом.** Методы напоминают функции, только их определяют внутри класса и вызывают в объекте, созданном классом (как в части I, когда вы вызывали методы вроде "hello".upper() в строках). Имена методов, как и функций, должны указываться строчными буквами, а слова должны быть отделены нижними подчеркиваниями.  

Методы определяются с помощью такого же синтаксиса, что и функции, с двумя отличиями: нужно определить метод как тело в классе, и он должен принимать, по меньшей мере, один параметр (за исключением особых случаев). По соглашению, первый параметр метода всегда называется `self`. При создании метода вы должны всегда определять хотя бы один параметр, поскольку, когда метод вызывается в объекте, Python автоматически передает вызвавший метод объект в этот метод в качестве параметра.  

Вы можете использовать параметр `self`, чтобы определить *переменную экземпляра* — переменную, принадлежащую объекту. Если вы создадите несколько объектов, у них всех будут разные значения переменных экземпляра. Переменные экземпляра объявляются с помощью синтаксиса `self.имя_переменной = значение_переменной`. Обычно переменные экземпляра определяются внутри специального метода `__init__` (от англ. слова `initialize` — инициализировать), который вызывается Python при создании объекта.  

Любой метод, окруженный двойными нижними подчеркиваниями (как `__init__`), является **магическим методом,** который Python использует для особых целей, таких как создание объекта.  

Вы можете создать новый объект `Orange` с помощью того же синтаксиса, что вы использовали для вызова функции — `имя_функции(параметры)` — только замените `имя_функции` именем класса, который вы хотите использовать для создания объекта, а слово — `параметры`, которые принимает `__init__`. Не нужно передавать `self`, Python сделает это автоматически. Создание нового объекта называется **созданием экземпляра класса.** Как только вы создали объект, можно получить значение его переменных экземпляра с помощью синтаксиса `имя_объекта.имя_переменной`.  

Значение переменной экземпляра можно изменить с помощью синтаксиса `имя_объекта.имя_переменной = новое_значение`. Используя класс `Orange`, вы можете создать множество апельсинов. Апельсин не определяется одними только физическими свойствами вроде цвета и веса. Апельсины делают разные вещи — например, гниют — и вы можете смоделировать их с помощью методов.

```python
class Orange():
    def __init__(self, w, c):
        """weight in gramms"""
        self.weight = w
        self.color = c
        self.mold = 0
        print("Created!")

    def rot(self, days, temp):
        self.mold = days * temp

orange = Orange(6, "orange")
print(orange.mold)
orange.rot(10, 33)
print(orange.mold)

>>> Created!
>>> 0
>>> 330
```

У объектно-ориентированного программирования есть несколько преимуществ. Эта парадигма способствует повторному использованию кода и вследствие этого сокращает количество времени, необходимое на разработку и обслуживание кода. Проблемы разбиваются на множество фрагментов, благодаря чему код становится легче поддерживать. Недостатком объектно-ориентированного программирования можно считать то, что создание программ требует больших усилий, поскольку их разработка включает огромный объем планирования.

### Словарь терминов Глава 12

**Глобальное состояние:** значение глобальных переменных в программе при ее работе.  
**Классы:** механизм, позволяющий программисту классифицировать и сгруппировывать похожие объекты.  
**Магический метод:** метод, который Python использует в разных ситуациях, например, при создании объекта.  
**Методы:** тело в классах. Методы похожи на функции, только их определяют внутри класса и вызывают только в объекте, созданном классом.  
**Объектно-ориентированное программирование:** парадигма программирования, где вы определяете объекты, которые взаимодействуют друг с другом.  
**Парадигма программирования:** стиль программирования.  
**Переменные экземпляра:** переменные, которые принадлежат объекту.  
**Побочный эффект:** изменение состояния глобальной переменной.  
**Процедурное программирование:** стиль программирования, в котором пишется последовательность шагов по направлению к решению, и каждый шаг изменяет состояние программы.  
**Создание экземпляра класса:** создание нового объекта при помощи класса.  
**Состояние:** это значение переменных в программе во время ее работы.  
**Функциональное программирование:** решает проблемы процедурного программирования с помощью устранения глобального состояния, передавая его от функции к функции.  
**Экземпляр:** каждый объект это экземпляр класса. Каждый экземпляр класса имеет тот же тип, что и все остальные экземпляры этого класса.