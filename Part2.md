# ЧАСТЬ II Введение в объектно-ориентированное программирование

<!-- TOC -->

- [ЧАСТЬ II Введение в объектно-ориентированное программирование](#часть-ii-введение-в-объектно-ориентированное-программирование)
    - [Глава 12. Парадигмы программирования](#глава-12-парадигмы-программирования)
        - [Состояние](#состояние)
        - [Процедурное программирование](#процедурное-программирование)
        - [Функциональное программирование](#функциональное-программирование)
        - [Объектно-ориентированное программирование](#объектно-ориентированное-программирование)
        - [Словарь терминов Глава 12](#словарь-терминов-глава-12)
    - [Глава 13. Четыре столпа объектно-ориентированного программирования](#глава-13-четыре-столпа-объектно-ориентированного-программирования)
        - [Инкапсуляция](#инкапсуляция)
        - [Абстракция](#абстракция)
        - [Полиморфизм](#полиморфизм)
        - [Наследование](#наследование)
        - [Композиция](#композиция)
        - [Словарь терминов Глава 13](#словарь-терминов-глава-13)

<!-- /TOC -->

## Глава 12. Парадигмы программирования

> Существуют лишь два вида языков программирования: те, которые постоянно ругают, и те, которыми никто не пользуется.
> *Бьерн Страуструп*

**Парадигма программирования** — это стиль программирования. Существует множество различных парадигм программирования. Для того чтобы программировать профессионально, вам нужно изучить парадигмы либо объектно-ориентированного, либо функционального программирования.

### Состояние

Одним из фундаментальных различий между разными парадигмами программирования является управление **состоянием.** Состояние — это значение переменных в программе при ее работе. **Глобальное состояние** — значение глобальных переменных в программе при ее работе.  

### Процедурное программирование

В части I вы программировали, используя парадигму процедурного программирования — стиль программирования, в котором пишется последовательность шагов по направлению к решению, и каждый шаг изменяет состояние программы. В процедурном программировании вы пишете код, чтобы «сделать это, затем то».  
Когда вы используете процедурное программирование, то сохраняете данные в глобальных переменных и управляете ими при помощи функций. Процедурное программирование подходит для написания небольших программ. Что все состояния программы сохраняются в глобальных переменных, когда код становится больше, появляются проблемы. Проблема с использованием глобальных переменных заключается в том, что они вызывают непредвиденные ошибки. Когда код вашей программы увеличивается в размере, вы используете глобальные переменные в большом количестве функций, и невозможно отследить все места, в которых глобальная переменная изменяется. Например, функция может изменить значение глобальной переменной, а позже в программе другая функция может изменить ту же глобальную переменную, потому что программист, написавший вторую функцию, забыл, что глобальная переменная уже была изменена первой функцией. Подобные ситуации возникают довольно часто, искажая код программы.  

По мере того, как ваша программа усложняется, количество глобальных пе ременных в ней возрастает. Когда это возрастание совмещается с увеличением числа функций, необходимых программе для обработки новой функциональности, каждая из которых изменяет глобальные переменные, код вашей программы быстро становится непригодным для обслуживания. Более того, этот подход к программированию опирается на **побочные эффекты.** Побочный эффект — это изменение состояния глобальной переменной. При процедурном программировании вы будете часто сталкиваться с непреднамеренными побочными эффектами, такими как случайное двукратное увеличение переменной. Эта проблема привела к развитию парадигм объектно-ориентированного и функционального программирования, и эти парадигмы используют разные подходы к ее решению.  

### Функциональное программирование

Функциональное программирование происходит от лямбда-исчисления — наименьшего в мире универсального языка программирования (созданного математиком Алонзо Черчем). Функциональное программирование решает проблемы процедурного программирования с помощью устранения глобального состояния. Функциональный программист полагается на функции, которые не используют и не изменяют глобальное состояние; единственное используемое ими состояние — параметры, которые вы передаете в функцию. Результат, возвращаемый функцией, обычно передается в другую функцию. Таким образом, выполняя передачу из функции в функцию, функциональный программист избегает глобального состояния. Отказ от глобального состояния избавляет от побочных эффектов и сопутствующих им проблем.  

Программист из Великобритании, Мэри Роуз Кук, дает функциональному программированию такое определение: «Функциональный код отличается одним свойством: отсутствием побочных эффектов. Он не полагается на данные вне текущей функции, и не меняет данные, находящиеся вне функции».  

Преимущество функционального программирования заключается в том, что оно устраняет целую категорию ошибок, вызванных глобальным состоянием (в функциональном программировании нет глобального состояния). Его недостаток заключается в том, что некоторые проблемы легче осмыслить при помощи состояния. К примеру, проектирование пользовательского интерфейса с глобальным состоянием легче концептуализировать, чем интерфейс без него. Если вы хотите написать программу, где будет кнопка, нажатие которой переключает режим изображения между видимым и скрытым, такую кнопку проще создать в программе с глобальным состоянием. Можно создать глобальную переменную, принимающую значение `True` или `False` и в зависимости от своего те кущего состояния скрывающую или показывающую это изображение. Без глобального состояния создать такую кнопку сложнее.  

### Объектно-ориентированное программирование

Парадигма **объектно-ориентированного программирования** также решает проблемы, возникающие в процедурном программировании путем устранения глобального состояния, но здесь состояние сохраняется не в функциях а в объектах. В объектно-ориентированном программировании **классы** определяют набор объектов, которые могут взаимодействовать между собой. Классы являются механизмом, позволяющим программисту классифицировать и сгруппировывать похожие объекты. Представьте пакет апельсинов. Каждый апельсин — это объект. Все апельсины обладают схожими свойствами, такими как цвет и вес, но значения этих свойств разные у каждого апельсина. Вы можете использовать класс, чтобы смоделировать апельсины и создать объекты апельсинов с разными значениями. Например, можно определить класс, позволяющий создать объект апельсина темного цвета, весящего 300 грамм, и объект светлого апельсина весом 350 грамм.  

Каждый объект — это **экземпляр** класса. Если вы определите класс `Orange` и создадите два объекта `Orange`, каждый из них будет экземпляром класса `Orange`, и у них будет одинаковый тип данных — Orange. Термины «объект» и «экземпляр» взаимозаменяемы. При определении класса экземпляры класса будут похожими — они все будут иметь свойства, определенные в их классе, как цвет или вес для класса, представляющего апельсин, — но свойства каждого экземпляра будут иметь разные значения.  

В Python класс является составной инструкцией с заголовком и телом . Класс определяется при помощи синтаксиса `class имя: тело`, где `имя` — это имя класса, `тело` — определяемое вами тело класса. По соглашению, имена классов в Python всегда начинаются с прописной буквы и записываются в **горбатом регистре,** то есть при наличии в имени класса больше одного слова первые буквы всех слов нужно сделать прописными (`LikeThis`), а не добавлять между словами нижние подчеркивания, как с именами функций. Тело в классе может быть простой или составной инструкцией, называемой **методом.** Методы напоминают функции, только их определяют внутри класса и вызывают в объекте, созданном классом (как в части I, когда вы вызывали методы вроде "hello".upper() в строках). Имена методов, как и функций, должны указываться строчными буквами, а слова должны быть отделены нижними подчеркиваниями.  

Методы определяются с помощью такого же синтаксиса, что и функции, с двумя отличиями: нужно определить метод как тело в классе, и он должен принимать, по меньшей мере, один параметр (за исключением особых случаев). По соглашению, первый параметр метода всегда называется `self`. При создании метода вы должны всегда определять хотя бы один параметр, поскольку, когда метод вызывается в объекте, Python автоматически передает вызвавший метод объект в этот метод в качестве параметра.  

Вы можете использовать параметр `self`, чтобы определить *переменную экземпляра* — переменную, принадлежащую объекту. Если вы создадите несколько объектов, у них всех будут разные значения переменных экземпляра. Переменные экземпляра объявляются с помощью синтаксиса `self.имя_переменной = значение_переменной`. Обычно переменные экземпляра определяются внутри специального метода `__init__` (от англ. слова `initialize` — инициализировать), который вызывается Python при создании объекта.  

Любой метод, окруженный двойными нижними подчеркиваниями (как `__init__`), является **магическим методом,** который Python использует для особых целей, таких как создание объекта.  

Вы можете создать новый объект `Orange` с помощью того же синтаксиса, что вы использовали для вызова функции — `имя_функции(параметры)` — только замените `имя_функции` именем класса, который вы хотите использовать для создания объекта, а слово — `параметры`, которые принимает `__init__`. Не нужно передавать `self`, Python сделает это автоматически. Создание нового объекта называется **созданием экземпляра класса.** Как только вы создали объект, можно получить значение его переменных экземпляра с помощью синтаксиса `имя_объекта.имя_переменной`.  

Значение переменной экземпляра можно изменить с помощью синтаксиса `имя_объекта.имя_переменной = новое_значение`. Используя класс `Orange`, вы можете создать множество апельсинов. Апельсин не определяется одними только физическими свойствами вроде цвета и веса. Апельсины делают разные вещи — например, гниют — и вы можете смоделировать их с помощью методов.

```python
class Orange():
    def __init__(self, w, c):
        """weight in gramms"""
        self.weight = w
        self.color = c
        self.mold = 0
        print("Created!")

    def rot(self, days, temp):
        self.mold = days * temp

orange = Orange(6, "orange")
print(orange.mold)
orange.rot(10, 33)
print(orange.mold)

>>> Created!
>>> 0
>>> 330
```

У объектно-ориентированного программирования есть несколько преимуществ. Эта парадигма способствует повторному использованию кода и вследствие этого сокращает количество времени, необходимое на разработку и обслуживание кода. Проблемы разбиваются на множество фрагментов, благодаря чему код становится легче поддерживать. Недостатком объектно-ориентированного программирования можно считать то, что создание программ требует больших усилий, поскольку их разработка включает огромный объем планирования.

### Словарь терминов Глава 12

**Глобальное состояние:** значение глобальных переменных в программе при ее работе.  
**Классы:** механизм, позволяющий программисту классифицировать и сгруппировывать похожие объекты.  
**Магический метод:** метод, который Python использует в разных ситуациях, например, при создании объекта.  
**Методы:** тело в классах. Методы похожи на функции, только их определяют внутри класса и вызывают только в объекте, созданном классом.  
**Объектно-ориентированное программирование:** парадигма программирования, где вы определяете объекты, которые взаимодействуют друг с другом.  
**Парадигма программирования:** стиль программирования.  
**Переменные экземпляра:** переменные, которые принадлежат объекту.  
**Побочный эффект:** изменение состояния глобальной переменной.  
**Процедурное программирование:** стиль программирования, в котором пишется последовательность шагов по направлению к решению, и каждый шаг изменяет состояние программы.  
**Создание экземпляра класса:** создание нового объекта при помощи класса.  
**Состояние:** это значение переменных в программе во время ее работы.  
**Функциональное программирование:** решает проблемы процедурного программирования с помощью устранения глобального состояния, передавая его от функции к функции.  
**Экземпляр:** каждый объект это экземпляр класса. Каждый экземпляр класса имеет тот же тип, что и все остальные экземпляры этого класса.

## Глава 13. Четыре столпа объектно-ориентированного программирования

> Хороший дизайн приносит пользу быстрее, чем увеличивает расходы.
> *Томас Гейл*

В объектно-ориентированном программировании есть четыре главные концепции: инкапсуляция, абстракция, полиморфизм и наследование. Вместе они образовывают **четыре столпа объектно-ориентированного программирования.**  

### Инкапсуляция

Инкапсуляция относится к двум концепциям. Первая заключается в том, что в объектно-ориентированном программировании переменные (состояние) и методы (для изменения состояния либо выполнения вычислений, использующих состояние) группируются в единое целое — объект.  

Вторая концепция, собственно инкапсуляция, заключается в сокрытии внутренних данных класса для предотвращения получения **клиентом** (кодом вне класса, который использует объект) прямого доступа к этим данным.  

Многие языки программирования решают эту проблему, разрешая программистам определять **закрытые переменные** и **закрытые методы** — переменные и методы, к которым могут обращаться объекты в коде, реализующем различные методы, но клиент не может. Закрытые переменные и методы полезны, когда у вас есть метод или переменные, используемые внутри класса, но вы планируете позже изменить реализацию своего кода (или желаете сохранить гибкость этой опции) и потому не хотите, чтобы тот, кто использует этот класс, полагался на них (ведь они могут измениться и нарушить код клиента). Закрытые переменные являются примером второй концепции, к которой относится инкапсуляция; закрытые переменные скрывают внутренние данные класса от прямого доступа к ним клиента. В противоположность, **открытые переменные** — это те, к которым клиент может получить доступ.  

В Python нет закрытых переменных. Все его переменные — открытые. К решению проблемы, с которой справляются закрытые переменные, Python подходит иным образом — используя конвенции (соглашения) имен. Если у вас есть переменная или метод, к которым вызывающий их не должен получить доступ, перед их именами необходимо добавить нижнее подчеркивание. Программисты Python знают, что если имя метода или переменной начинается с символа подчеркивания, их нельзя использовать (хотя они все еще могут попытаться сделать это на свой страх и риск).  

```python
class PublicPrivateExample:
    def __init__(self):
        self.public = "безопасно"
        sefl._unsafe = "опасно"

    def public_method(self):
        # клиенты могут это использовать
        pass

    def _unsafe_method(self):
        # клиенты не должны это использовать
        pass
        self.public = "безопасно"
        self._unsafe = "опасно"
```

Программисты, читающие этот код, понимают, что переменную `self.public` использовать безопасно, но они не должны использовать переменную `self._unsafe`, поскольку она начинается **с подчеркивания**, — а если все же решает ее использовать, то на свой страх и риск.

### Абстракция

**Абстракция** — это процесс [«отнятия или удаления у чего-то характеристик с целью сведения его к набору основных, существенных характеристик»](https://whatis.techtarget.com/definition/abstraction). В объектно-ориентированном программировании абстракция используется, когда объекты моделируются с использованием классов, а ненужные подробности опускаются.

Скажем, вы создаете модель человека. Человек комплексен — у него есть цвет волос, цвет глаз, рост, вес, этническая принадлежность, пол и многое другое. Если для представления человека вы создадите класс, некоторые из этих данных могут оказаться не важными в контексте проблемы, которую вы пытаетесь решить. Примером абстракции может быть создание класса `Person` с опущением некоторых свойств человека, например, цвета глаз или веса. Объекты `Person`, которые создает ваш класс, являются абстракциями людей. Это представление человека, урезанное до основных характеристик, необходимых для решения конкретной проблемы.

### Полиморфизм

Полиморфизмом называют [«способность (в программировании) представлять один и тот же интерфейс для разных базовых форм (типов данных)»](https://stackoverflow.com/questions/1031273/what-is-polymorphism-what-is-it-for-and-how-is-it-used). Интерфейс — это функция или метод. Встроенная функция `type` возвращает тип данных объекта.

```python
print("Hello, world!")
print(200)
print(200.1)
```

Вы представили один интерфейс, функцию print, для трех разных типов данных: строки, целого числа и числа с плавающей точкой. Вам не нужно определять и вызывать три отдельных функции (вроде print_string для вывода строк, print_int для вывода целых чисел и print_float для вывода чисел с плавающей точкой), чтобы вывести три разных типа данных; вместо этого вы использовали функцию print для представления одного интерфейса, чтобы вывести их все.  

```python
# Рисование фигур без полиморфизма
shapes = [tr1, sq1, cr1]
for a_shape in shapes:
    if type(a_shape) == "Triangle":
        a_shape.draw_triangle()
    if type(a_shape) == "Square":
        a_shape.draw_square()
    if type(a_shape) == "Circle":
        a_shape.draw_circle()

# Рисуем фигуры с помощью полиморфизма
shapes = [tr1, sq1, cr1]
for a_shape in shapes:
    a_shape.draw()
```

Если бы вы пожелали добавить новую фигуру в список shapes без полиморфизма, вам пришлось бы изменить код в цикле for, чтобы проверить тип a_shape, и вызывать его метод рисования. С помощью единообразного полиморфического интерфейса вы може те впредь добавлять столько классов фигур в список shapes, сколько пожелаете, и фигура будет рисовать себя без какого-либо дополнительного кода.

### Наследование

Наследование в программировании напоминает наследование в биологии. При генетическом наследовании вы наследуете характеристики вроде цвета глаз от родителей. Аналогично, когда вы создаете класс, он может наследовать методы и переменные от другого класса. Класс, от которого наследуют, называется **родительским**, а класс, который наследует, — **дочерним.**  

### Композиция

Еще одна важная концепция это — композиция. Композиция создает отношение «имеет», сохраняя объект в другом объекте как переменную. Например, композиция может использоваться для представления отношения между собакой и ее хозяином (собака имеет хозяина).  

### Словарь терминов Глава 13

**Абстракция:** процесс «отнятия или удаления у чего-то характеристик с целью сведения его к набору основных, существенных характеристик».  
**Дочерний класс:** класс, который наследуется.  
**Инкапсуляция:** относится к двум концепциям. Первая заключается в том, что в объектно-ориентированном программировании переменные (состояние) и методы (для изменения состояния либо выполнения вычислений, использующих состояние) группируются в единое целое — объект. Вторая концепция, собственно инкапсуляция, заключается в сокрытии внутренних данных класса для предотвращения получения клиентом прямого доступа к этим данным.  
**Клиент:** код вне класса, который использует объект.  
**Композиция:** композиция моделирует отношение «имеет», сохраняя объект в другом объекте как переменную.  
**Наследование:** при генетическом наследовании вы наследуете свойства вроде цвета глаз от родителей. Аналогично, когда вы создаете класс, он может наследовать методы и переменные от другого класса.  
**Переопределение метода:** способность дочернего класса изменять реализацию метода, унаследованного от его родительского класса.  
**Полиморфизм:** полиморфизмом называют «способность (в программировании) представлять один и тот же интерфейс для разных базовых форм (типов данных)».  
**Родительский класс:** класс, от которого осуществляется наследование.  
Четыре столпа объектно-ориентированного программирования: четыре главные концепции в объектно-ориентированном программировании: наследование, полиморфизм, абстракция и инкапсуляция.